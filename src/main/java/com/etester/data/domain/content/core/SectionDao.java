package com.etester.data.domain.content.core;

import java.util.List;

import com.etester.data.domain.content.Printsectionsettings;
import com.etester.data.domain.content.instance.Usersectionresponse;
import com.etester.data.domain.user.Mysection;
import com.etester.data.domain.util.UpdateStatusBean;

public interface SectionDao {
	
	// Beware, tables names are case sensitive in MySQL on Linux.  Set all to lower case
	// Although not necessary, I am also doing the same with all column names.
	public static final String insertSectionSQL = "INSERT INTO section (id_section, id_provider, id_skill, name, description, text, is_linktext, linktext_address, addl_info, time_to_answer, auto_generated, generator_metadata, question_banner, question_heading, question_instructions, is_external, section_type, is_practice) "
			+ " VALUES (:idSection, :idProvider, :idSkill, :name, :description, :text, :isLinktext, :linktextAddress, :addlInfo, :timeToAnswer, :autoGenerated, :generatorMetadata, :questionBanner, :questionHeading, :questionInstructions, :isExternal, :sectionType, :isPractice)";

	// Note:  I am not updating sectionType
	public static final String updateSectionSQL = "UPDATE section SET name = :name, description = :description, text = :text, is_linktext = :isLinktext, linktext_address = :linktextAddress, addl_info = :addlInfo, " +
			" time_to_answer = :timeToAnswer, auto_generated = :autoGenerated, generator_metadata = :generatorMetadata, question_banner = :questionBanner, question_heading = :questionHeading, question_instructions = :questionInstructions, " +
			" is_external = :isExternal, is_practice = :isPractice " +
			" WHERE id_section = :idSection ";

//	public static final String updateSectionSQL2 = "UPDATE section SET name = :name, description = :description, text = :text, addl_info = :addlInfo, " +
//			" question_banner = :questionBanner, question_heading = :questionHeading, question_instructions = :questionInstructions " +
//			" WHERE id_section = :idSection ";

	// default the section values for pointsPerQuestion & negativePointsPerQuestion - since we know these values do not exist on a section, just fake some defaults
	public static final String findSectionBySectionIdSQL = "SELECT s.*, 1.0 AS points_per_question, 0.0 AS negative_points_per_question, 0.0 AS unanswered_points_per_question FROM section s WHERE id_section = :idSection";
//	public static final String findSectionBySectionIdSQL = "SELECT s.*,  FROM section s WHERE id_section = :idSection";

	public static final String findByArtifactIdSectionIdWithResponseSQL = "SELECT usr.* FROM usersectionresponse usr WHERE usr.id_artifact = :idArtifact AND usr.id_section = :idSection AND usr.id_user = :idUser ";
	public static final String findAdaptiveSectionsForArtifactSQL = "SELECT s.* FROM section s WHERE id_section = (SELECT MAX(at.id_section) FROM adaptive_test at WHERE at.id_core_artifact = :idArtifact) ";
	
//	public static final String findAssessmentSectionsWithResponseForArtifactSQL = "SELECT s.id_section, at.name, s.text, s.addl_info, s.time_to_answer, s.question_banner, s.question_heading, s.question_instructions, s.is_practice "
//			+ "	FROM section s LEFT JOIN adaptive_test at ON at.id_section = s.id_section "
//			+ "	WHERE at.test_mode = 'E' AND at.id_core_artifact = :idArtifact " ;
//	
//	public static final String findAssessmentSectionsWithResponseForArtifactAndSectionSQL = findAssessmentSectionsWithResponseForArtifactSQL 
//						+ " AND at.id_section = :idSection " ;
	
	public static final String findAssessmentSectionsWithResponseForArtifactSQL = 
			" SELECT s.id_section AS id_section, at.name AS section_name, "
			+ "	  usr.date_saved AS date_saved, usr.response AS response, at.id_core_artifact AS id_artifact "
			+ "	FROM section s LEFT JOIN adaptive_test at ON at.id_section = s.id_section "
			+ "					LEFT OUTER JOIN usersectionresponse usr ON usr.id_section = s.id_section AND usr.id_user = :idUser "
			+ "	WHERE at.test_mode = 'E' AND at.id_core_artifact = :idArtifact ";
	
	public static final String findAssessmentSectionsWithResponseForArtifactAndSectionSQL = findAssessmentSectionsWithResponseForArtifactSQL 
						+ " AND at.id_section = :idSection " ;
	
//	public static String updateTestSQL = "UPDATE test SET name = :name, description = :description, text = :text, addl_info = :addlInfo, " +
//			" timed = :timed, time_to_answer = :timeToAnswer, published = :published, access_level = :accessLevel, test_type = :testType " +
//			" WHERE id_test = :idTest and id_provider = :idProvider";

	public static final String insertQuestionsetSQL = "INSERT INTO questionset (id_questionset, id_section, text) "
			+ " VALUES (:idQuestionset, :idSection, :text)";

//	public static final String upsertQuestionsetSQL = "INSERT INTO questionset (id_questionset, id_section, text) "
//			+ " VALUES (:idQuestionset, :idSection, :text) "
//			+ " ON DUPLICATE KEY UPDATE text = :text ";

	public static final String insertMysectionSQL = "INSERT INTO mysection (id_mysection, id_section, id_provider, name, description) "
			+ " VALUES (:idMysection, :idSection, :idProvider, :name, :description)";

	public static final String selectSectionListWithParentSkillInfoSQL = "SELECT s.name AS skill_name, s.description AS skill_description, ss.* FROM skill s join section ss ON s.id_skill = ss.id_skill and s.id_skill = :idSkill";

	public static final String upsertUsersectionresponseSQL = "INSERT INTO usersectionresponse (id_user, id_section, id_artifact, response, date_saved) "
			+ " VALUES (:idUser, :idSection, :idArtifact, :response, Now()) "
			+ " ON DUPLICATE KEY UPDATE response = :response, date_saved = Now()";

	public static final String upsertPracticeinstanceSQL = "INSERT INTO practiceinstance (id_user, id_artifact, artifact_type, practice_status, practice_method, practice_additional_info, date_saved) "
			+ " VALUES (:idUser, :idArtifact, :artifactType, :practiceStatus, :practiceMethod, :practiceAdditionalInfo, Now()) "
			+ " ON DUPLICATE KEY UPDATE practice_status = :practiceStatus, practice_additional_info = :practiceAdditionalInfo, date_saved = Now()";

	public static final String deleteUsersectionresponseSQL = "DELETE FROM usersectionresponse "
			+ "WHERE id_user = :idUser AND id_section = :idSection AND id_artifact = :idArtifact ";

	// Retrieving the question sets separately .... no need for question set text as part of question...
//	public static final String findQuestionsForSectionSQL = "SELECT q.*, qs.`text` AS questionset_text "
//			+ " FROM question q LEFT JOIN questionset qs ON q.id_questionset = qs.id_questionset "
//			+ " WHERE q.id_section = :idSection "
//			+ " ORDER BY q.id_question";

	public static final String findQuestionsForSectionSQL = "SELECT q.* "
			+ " FROM question q "
			+ " WHERE q.id_section = :idSection "
			+ " ORDER BY q.id_question";

	public static final String findQuestionsetsForSectionSQL = "select qs.* "
			+ "	FROM questionset qs LEFT JOIN question q ON qs.id_questionset = q.id_questionset "
			+ "	WHERE q.id_section = :idSection "
			+ " GROUP BY qs.id_questionset "
			+ " ORDER BY q.id_questionset";

	// Retrieving the question sets separately .... no need for question set text as part of question...
//	public static final String findQuestionsForDerivedSectionSQL = "SELECT q.*, qs.`text` AS questionset_text, dsq.`question_order` AS question_order "
//			+ " FROM derived_section_question dsq LEFT JOIN question q ON dsq.id_question = q.id_question "
//			+ " LEFT JOIN questionset qs ON q.id_questionset = qs.id_questionset "
//			+ " WHERE dsq.id_section = :idSection "
//			+ " ORDER BY dsq.question_order";

	public static final String findQuestionsForDerivedSectionSQL = "SELECT q.*, dsq.`question_order` AS question_order "
			+ " FROM derived_section_question dsq LEFT JOIN question q ON dsq.id_question = q.id_question "
			+ " WHERE dsq.id_section = :idSection "
			+ " ORDER BY dsq.question_order";

	public static final String findQuestionsetsForDerivedSectionSQL = "select qs.* "
			+ "	FROM questionset qs LEFT JOIN question q ON qs.id_questionset = q.id_questionset "
			+ "	LEFT JOIN derived_section_question dsq ON dsq.id_question = q.id_question "
			+ "	WHERE dsq.id_section = :idSection "
			+ "	GROUP BY qs.id_questionset "
			+ "	ORDER BY qs.id_questionset";

	public static String findQuestionByQuestionIdSQL = "SELECT * FROM question WHERE id_question = :idQuestion";

	public static final String findAnswersForQuestionSQL = "SELECT * FROM answer WHERE id_question = :idQuestion ORDER BY id_answer";

	public static final String insertDerivedSectionQuestionSQL = "INSERT INTO derived_section_question (id_section, id_question, question_order) "
			+ " VALUES (:idSection, :idQuestion, :questionOrder)";

	// Exclusively used in Download functionality
	public static final String findDerivedSectionQuestionsForSectionSQL = "SELECT * FROM derived_section_question WHERE id_section = :idSection ORDER BY question_order";

	
	// Update Question Functionality
	// Note:  I am not updating sectionType
	public static final String saveQuestionTextSQL = "UPDATE question SET text = :text WHERE id_question = :idQuestion ";
	public static final String saveAnswerTextSQL = "UPDATE answer SET text = :text WHERE id_answer = :idAnswer ";
	public static final String saveQuestionAddlInfoSQL = "UPDATE question SET addl_info = :addlInfo WHERE id_question = :idQuestion ";


	public Section findBySectionId(Long idSection);

	// Used in PracticeSection functionality
	public Usersectionresponse findBySectionIdWithResponse(Long idSection);
	public Usersectionresponse findByArtifactIdSectionIdWithResponse(Long idArtifact, Long idSection);

	// Used in PracticeSection functionality
	public Integer saveUsersectionresponseForCurrentUser(Usersectionresponse usersectionresponse);

    public List<Section> findSectionsForSectionIdList(List<Long> idSection);
    
    public List<Section> findSectionsForSkill (Long idSkill);

    public List<Section> findSectionsForSkillWithQuestions (Long idSkill);

    // Function used exclusively to retrieve section to serve as a practice as a consequence of test reports
    public Section findAdaptiveSectionsForArtifact (Long idArtifact);

    // Methods used in download functionality
    public List<Section> findSectionsForSkillWithQuestionsForDownload (Long idSkill);
	public Section findSectionBySectionIdForDownload(Long idSection);


	public void insert(Section section);

    public void update(Section section);

    public void delete(Long idSection);

    public List<UpdateStatusBean> insertBatch(List<Section> sections);

    // This deletes the data before reloading the same
    public List<UpdateStatusBean> insertBatch(List<Section> sections, boolean reload);

    /**
     * Utility method that perhaps belongs on QuestionDao - but since I do not USE a QuestionDao, I am listing it here.
     * @param idQuestion
     * @return
     */
	public void addSectionsToMyList(List<Long> sectionIdList);

	public void saveSectionsToMyList(List<Long> sectionIdList);

	public void addMysections(List<Mysection> mysectionList);
	
	public void saveMysections(List<Mysection> mysectionList);
    
	public List<Section> getMySectionList();
	
	// Derived Section Calls
	
	/**
	 * Find all Derived Sections for a Skill 
	 * @param idSkill
	 * @return
	 */
	public List<Section> findDerivedSectionsForSkill (Long idSkill);
	
    /**
     * Save a Derived Section
     * @param derivedSection
     * @return
     */
	public Integer saveDerivedSection(Section derivedSection);
	
	/**
	 * Delete an Existing Derived Section
	 * @param idDerivedSection
	 * @return
	 */
    public Integer deleteDerivedSection(Long idDerivedSection);

    /**
     * Retrieve the section associated with the Artifact for Assessment Purposes.  Note that there may be multiple sections associated 
     * with the artifact.  This will retrieve ALL such sections.
     * @param idArtifact
     * @return
     */
	public List<Usersectionresponse> findAssessmentSectionsWithResponseForArtifact(Long idArtifact);
	/**
	 * Retrieve the section associated with the Artifact for Assessment Purposes.  Note that there may be multiple sections associated.
	 * In this case only the section identified by the section ID is retrieved.
	 * @param idArtifact
	 * @param idSection
	 * @return
	 */
	public List<Usersectionresponse> findAssessmentSectionsWithResponseForArtifactAndSection(Long idArtifact, Long idSection);
	
	
	// For Question Edit Administrative Function
	public Question findQuestionForEdit(Long idQuestion);
    public Integer saveQuestionText(Question question);
    public Integer saveQuestionTextWithAnswers(Question question);
    public Integer saveQuestionExplanation(Question question);
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Print Functionality
    ////////////////////////////////////////////////////////////////////////////////////////////////////////
	public static final String findSectionBySectionIdForPrintSQL = "SELECT s.*, pss.settings AS printsectionsettings FROM section s LEFT JOIN printsectionsettings pss ON pss.id_section = s.id_section WHERE s.id_section = :idSection"; 

	public static final String updatePrintsectionsettingsSQL = "INSERT INTO printsectionsettings (id_section, settings, date_saved) VALUES (:idSection, :settings, :dateSaved) "
			+ " ON DUPLICATE KEY "
			+ " UPDATE settings = :settings, date_saved = :dateSaved ";

	public static final String deletePrintsectionsettingsSQL = "DELETE FROM printsectionsettings WHERE id_section = :idSection";

	
	
	/**
	 * Used to get a handle on the complete Test object (Testsegments, Testsections and Questions with Answers).  
	 * Used for print purposes.
	 * @param idTest
	 * @return
	 */
    public Section findSectionBySectionIdForPrint(Long idSection);
	/**
     * Invoked by a Administrator to save any settings on the Section.
     * @param printsectionsettings
     * @return
     */
    public Integer savePrintsectionsettings(Printsectionsettings printsectionsettings);
   
	/**
     * Invoked by a Administrator to delete any settings on the Section.
     * @param idSection
     * @return
     */
    public Integer deletePrintsectionsettings(Long idSection);
   

	
}
